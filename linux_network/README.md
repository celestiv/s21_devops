# Linux Network

## Part 1. Инструмент **ipcalc**

`-` Итак, начнём наше погружение в удивительный мир сетей со знакомства с IP адресами. А использовать для этого мы будем инструмент **ipcalc**.

**== Задание ==**

##### Поднять виртуальную машину (далее -- ws1)

#### 1.1. Сети и маски
##### Определить и записать в отчёт:
##### 1) адрес сети *192.167.38.54/13*

Видим адрес сети (Network): 192.160.0.0

![1.1.ipcalc-1](img/1/1.1.1.ipcalc_address.png)

##### 2) перевод маски *255.255.255.0* в префиксную и двоичную запись

Префикс - /24

Двоичная запись: 11111111 11111111 11111111 00000000

![1.2.ipcalc_mask](img/1/1.1.2.ipcalc_mask.png)

*/15* в обычную и двоичную

В обычной записи: 255.254.0.0

В двоичной записи: 11111111 1111111 0 00000000 00000000

![1.2.ipcalc_15](img/1/1.1.2.ipcalc_15.png)

*11111111.11111111.11111111.11110000* в обычную и префиксную

В обычной записи: 255.255.255.240

В префиксной записи: /28

![1.2.ipcalc_240](img/1/1.1.2.ipcalc_240.png)

##### 3) минимальный и максимальный хост в сети *12.167.38.4* при масках: */8*
Минимальный хост: 12.0.0.1

Максимальный хост: 12.255.255.254
![](img/1/1.1.3.ipcalc_minmax.png)

При маске **11111111.11111111.00000000.00000000**

Минимальный хост: 12.167.0.1

Максимальный хост: 12.167.255.254

![](img/1/1.1.3.ipcalc_minmax_16.png)

При маске *255.255.254.0*

Минимальный хост: 12.167.38.1

Максимальный хост: 12.167.39.254

![](img/1/1.1.3.ipcalc_minmax_23.png)

При маске */4*

Минимальный хост: 0.0.0.1

Максимальный хост: 15.255.255.254

![](img/1/1.1.3.ipcalc_minmax_4.png)

#### 1.2. localhost
##### Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP:

Смотрим нижнюю строку в выводе команды ipcalc с этими адресами и ищем слово ```Loopback```

*194.34.23.100* нельзя

![localhost](img/1/1.2.localhost_1.png)

*127.0.0.2* можно

![localhost](img/1/1.2.localhost_2.png)

*127.1.0.1* можно

![localhost](img/1/1.2.localhost_3.png)

*128.0.0.1* нельзя

![localhost](img/1/1.2.localhost_4.png)


#### 1.3. Диапазоны и сегменты сетей

##### Определить и записать в отчёт:
##### 1) какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных:

Чтобы ответить на этот вопрос, снова проверяем каждый адрес при помощи команды ```ipcalc```. Если в выводе в нижней строке с подписью Hosts/Net присутствует обозначение ```Private Internet```, значит адрес можно использовать только в качестве частного. Если подписи нет - можно использовать адрес в качестве публичного

*10.0.0.45* - Частный

![localhost](img/1/1.3.private_1.png)

*134.43.0.2* - Публичный

![localhost](img/1/1.3.private_2.png)

*192.168.4.2* - Частный

![localhost](img/1/1.3.private_3.png)

*172.20.250.4* - Частный

![localhost](img/1/1.3.private_4.png)

*172.0.2.1* - Публичный

![localhost](img/1/1.3.private_5.png)

*192.172.0.1* - Публичный

![localhost](img/1/1.3.private_6.png)

*172.68.0.2* - Публичный

![localhost](img/1/1.3.private_7.png)

*172.16.255.255* - Частный

![localhost](img/1/1.3.private_8.png)

*10.10.10.10* - Частный

![localhost](img/1/1.3.private_2.png)

*192.169.168.1* - Публичный

![localhost](img/1/1.3.private_2.png)

##### 2) какие из перечисленных IP адресов шлюза возможны у сети *10.10.0.0/18*:

Выбираем из списка только те адреса, которые находятся между HostMin и HostMax в результате запроса ```ipcalc 10.10.0.0/18```

*10.0.0.1* не может быть адресом шлюза

*10.10.0.2* может быть адресом шлюза

*10.10.10.10* может быть адресом шлюза

*10.10.100.1* не может быть адресом шлюза

*10.10.1.255* может быть адресом шлюза


## Part 2. Статическая маршрутизация между двумя машинами

`-` Теперь разберёмся, как связать две машины, используя статическую маршрутизацию.

**== Задание ==**

##### Поднять две виртуальные машины (далее -- ws1 и ws2)

##### С помощью команды `ip a` посмотреть существующие сетевые интерфейсы

Вывод команды на первой машине:

![](img/2/2.1.ws1_interfaces.png)

На второй машине:

![](img/2/2.1.ws2_interfaces.png)

##### Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски:

ws1 - *192.168.100.10*, маска */16*

![](img/2/2.1.ws1_netplan.png)

ws2 - *172.24.116.8*, маска */12*

![](img/2/2.1.ws2_netplan.png)

##### Выполнить команду `netplan apply` для перезапуска сервиса сети

![](img/2/2.1.ws1_netplan_apply.png)

![](img/2/2.1.ws2_netplan_apply.png)

#### 2.1. Добавление статического маршрута вручную
##### Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида `ip r add`
##### Пропинговать соединение между машинами

![](img/2/2.2.ws1_add_route.png)

![](img/2/2.2.ws2_add_route.png)

#### 2.2. Добавление статического маршрута с сохранением
##### Перезапустить машины
##### Добавить статический маршрут от одной машины до другой с помощью файла *etc/netplan/00-installer-config.yaml*

![](img/2/2.2.ws1_static_route.png)

![](img/2/2.2.ws2_static_route.png)

##### Пропинговать соединение между машинами

![](img/2/2.2.ws1_ping.png)

![](img/2/2.2.ws2_ping.png)

## Part 3. Утилита **iperf3**

**== Задание ==**

*В данном задании используются виртуальные машины ws1 и ws2 из Части 2*

#### 3.1. Скорость соединения

8 Mbps = 1 MB/s

100 MB/s = 800000 Kbps

1 Gbps 1000 Mbps


#### 3.2. Утилита **iperf3**
##### Измерить скорость соединения между ws1 и ws2

Флаг ```-s``` означает запустить режим сервера
```-f``` - формат вывода полученной скорости
```K``` - Килобайты в секунду

![](img/3/3.2.iperf3_listening.png)

![](img/3/3.2.iperf3_ping.png)

## Part 4. Сетевой экран

`-` После соединения машин, перед нами стоит следующая задача:
контролировать информацию, проходящую по соединению. Для этого
используются сетевые экраны.

**== Задание ==**

*В данном задании используются виртуальные машины ws1 и ws2 из Части 2*

#### 4.1. Утилита **iptables**
##### Создать файл */etc/firewall.sh*, имитирующий фаерволл, на ws1 и ws2:
```shell
#!/bin/sh

# Удаление всех правил в таблице "filter" (по-умолчанию).
iptables –F
iptables -X
```
##### Нужно добавить в файл подряд следующие правила:
##### 1) на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5)
##### 2) на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)
##### 3) открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)
##### 4) запретить *echo reply* (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)
##### 5) разрешить *echo reply* (машина должна "пинговаться")

![](img/4/4.1.ws1_iptables.png)

![](img/4/4.1.ws2_iptables.png)

##### Запустить файлы на обеих машинах командами `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`

![](img/4/4.1.ws1_launch.png)

![](img/4/4.1.ws2_launch.png)

Что получается в итоге:

С первой машины мы можем пингануть вторую, а вот со второй первая не пингуется. Дело в том, что правила из файла firewall.sh применяются в таком порядке, что первое написанное имеет больший приоритет перед написанными позднее. В данном случае разрешающее правило для echo-reply на второй машине сработало, а на первой - нет

#### 4.2. Утилита **nmap**
##### Командой **ping** найти машину, которая не "пингуется", после чего утилитой **nmap** показать, что хост машины запущен

![](img/4/4.1.ws1_ping_try.png)

![](img/4/4.1.ws2_ping_try.png)

Проверяем, запущена ли первая машина с помощью утилит nmap:

![](img/4/4.2.nmap.png)

В отчете видно сообщение ```Host is up```. Значит мы добились желаемого результата: машина ws1 запущена, firewall работает как и ожидалось

## Part 5. Статическая маршрутизация сети

`-` Пока что мы соединяли всего две машины, но теперь пришло время для статической маршрутизации целой сети.

**== Задание ==**

##### Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))

Изображение для примера:

![](img/5/5.1.network_route.png)

Подняты 5 машин:

![](img/5/5.1.machines.png)

#### 5.1. Настройка адресов машин
##### Настроить конфигурации машин в *etc/netplan/00-installer-config.yaml* согласно сети на рисунке.

![](img/5/5.1.ws11_netplan.png)

![](img/5/5.1.ws21_netplan.png)

![](img/5/5.1.ws22_netplan.png)

![](img/5/5.1.r1_netplan.png)

![](img/5/5.1.r2_netplan.png)

##### Перезапустить сервис сети. Если ошибок нет, то командой `ip -4 a` проверить, что адрес машины задан верно

![](img/5/5.1.ws1_netplan_apply.png)

![](img/5/5.1.ws21_netplan_apply.png)

![](img/5/5.1.ws22_netplan_apply.png)

![](img/5/5.1.r1_netplan_apply.png)

![](img/5/5.1.r2_netplan_apply.png)

##### Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.

![](img/5/5.1.ping_21_22.png)

![](img/5/5.1.ping_11_r1.png)

#### 5.2. Включение переадресации IP-адресов.
##### Для включения переадресации IP, выполните команду на роутерах:
`sysctl -w net.ipv4.ip_forward=1`
*При таком подходе переадресация не будет работать после перезагрузки системы.*

![](img/5/5.2.r1_sysctl.png)

![](img/5/5.2.r2_sysctl.png)

##### Откройте файл */etc/sysctl.conf* и добавьте в него следующую строку:
`net.ipv4.ip_forward = 1`
*При использовании этого подхода, IP-переадресация включена на постоянной основе.*

*В задании написано, что строчку нужно дописать, но если внимательно посмотреть содержание файла - то можно увидеть, что она уже есть. Просто раскомментируем*

![](img/5/5.2.r1_forward_file.png)

![](img/5/5.2.r2_forward_file.png)

#### 5.3. Установка маршрута по-умолчанию
Пример вывода команды `ip r` после добавления шлюза:
```
default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2
```

Вот так выглядит вывод команды ```ip r``` до настроек:

![](img/5/5.3.ws11_ip_r_before.png)

![](img/5/5.3.ws21_ip_r_before.png)

![](img/5/5.3.ws22_ip_r_before.png)

![](img/5/5.3.r1_ip_r_before.png)

![](img/5/5.3.r2_ip_r_before.png)

##### Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить `default` перед IP роутера в файле конфигураций

![](img/5/5.3.ws11_default.png)

![](img/5/5.3.ws21_default.png)

![](img/5/5.3.ws22_default.png)

##### Вызвать `ip r` и показать, что добавился маршрут в таблицу маршрутизации

![](img/5/5.3.ws11_after.png)

![](img/5/5.3.ws21_after.png)

![](img/5/5.3.ws22_after.png)

##### Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду:
`tcpdump -tn -i eth1`

Включаем tcpdump на r2:

![](img/5/5.3.r2_tcpdump.png)

И пингуем r2 с ws11:

![](img/5/5.3.ws11_ping_r2.png)

#### 5.4. Добавление статических маршрутов
##### Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:

```shell
# Добавить в конец описания сетевого интерфейса eth1:
- to: 10.20.0.0
  via: 10.100.0.12
```

![](img/5/5.4.r1_static_route.png)

![](img/5/5.4.r2_static_route.png)

##### Вызвать `ip r` и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:
```
10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.1
```

![](img/5/5.4.r1_ip_r_output.png)

![](img/5/5.4.r2_ip_r_output.png)

##### Запустить команды на ws11:
`ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0`

![](img/5/5.4.ws11_ip_list.png)

Почему для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по-умолчанию?

Потому что маршрут по умолчанию выбирается только в том случае, если нет других маршрутов, заданных вручную. При наличии нескольких маршрутов, выбирается тот у которого больше значение маски подсети, а значит адрес с маской 0 не будет выбран, если есть другой.

#### 5.5. Построение списка маршрутизаторов
Пример вывода утилиты **traceroute** после добавления шлюза:
```
1 10.10.0.1 0 ms 1 ms 0 ms
2 10.100.0.12 1 ms 0 ms 1 ms
3 10.20.0.10 12 ms 1 ms 3 ms
```
##### Запустить на r1 команду дампа:
`tcpdump -tnv -i eth0`
##### При помощи утилиты **traceroute** построить список маршрутизаторов на пути от ws11 до ws21

Включаем на роутере по номером 1 команду tcpdump

![](img/5/5.5.r1_tcpdump.png)

Вызываем ```traceroute 10.20.0.10```

![](img/5/5.5.ws11_traceroute.png)

Мы построили маршрут от машины ws11 до машины ws21, находящейся в другой локальной сети. как видим на скриншоте с выводом tcpdump, сначала машина ```ws11(10.10.0.2)``` соединяется по протоколу UDP со своим роутером ```r1(10.10.0.1)```, затем роутер r1 по протоколу ICMP передает сообщение другому роутеру ```r2(10.100.0.12)```, который в свою очередь связывается по протоколу UDP с машиной ```ws21(10.20.0.10)```

#### 5.6. Использование протокола **ICMP** при маршрутизации
##### Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:
`tcpdump -n -i eth0 icmp`

![](img/5/5.6.r1_tcpdump.png)

##### Пропинговать с ws11 несуществующий IP (например, *10.30.0.111*) с помощью команды:
`ping -c 1 10.30.0.111`

![](img/5/5.6.ws11_ping_unexisted.png)


## Part 6. Динамическая настройка IP с помощью **DHCP**

`-` Следующим нашим шагом будет более подробное знакомство со службой **DHCP**, которую ты уже знаешь.

**== Задание ==**

*В данном задании используются виртуальные машины из Части 5*

##### Для r2 настроить в файле */etc/dhcp/dhcpd.conf* конфигурацию службы **DHCP**:
##### 1) указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:
```shell
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}
```
Содержание измененного файла dhcpd.conf:

![](img/6/6.r2_dhcpd_conf.png)

##### 2) в файле *resolv.conf* прописать `nameserver 8.8.8.8.`

![](img/6/6.r2_resolv_conf.png)

##### Перезагрузить службу **DHCP** командой `systemctl restart isc-dhcp-server`. Машину ws21 перезагрузить при помощи `reboot` и через `ip a` показать, что она получила адрес. Также пропинговать ws22 с ws21.

![](img/6/6.r2_restart_dhcp.png)

![](img/6/6.ws21_ip_before.png)

![](img/6/6.ws21_ping_ws22.png)

##### Указать MAC адрес у ws11, для этого в *etc/netplan/00-installer-config.yaml* надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`

![](img/6/6.ws11_add_macaddress.png)

##### Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты

![](img/6/6.r1_dhcpd_conf.png)

![](img/6/6.r1_resolv_conf.png)

![](img/6/6.r1_restart_dhcp.png)

![](img/6/6.ws11_ip_before.png)

![](img/6/6.ws11_ip_after.png)

##### Запросить с ws21 обновление ip адреса

![](img/6/6.ws21_ip_addr.png)

![](img/6/6.ws21_new_addr.png)

Команда ```dhclient -r enp0s8``` использовалась для обновления ip адреса, полученного от dhcp - сервера


## Part 7. **NAT**

**== Задание ==**

*В данном задании используются виртуальные машины из Части 5*
##### В файле */etc/apache2/ports.conf* на ws22 и r1 изменить строку `Listen 80` на `Listen 0.0.0.0:80`, то есть сделать сервер Apache2 общедоступным

![](img/7/7.1.r1_apache_ports.png)

![](img/7/7.1.ws22_apache_ports.png)

##### Запустить веб-сервер Apache командой `service apache2 start` на ws22 и r1

![](img/7/7.1.r1_apache_start.png)

![](img/7/7.1.ws22_apache_start.png)

##### Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:
##### 1) удаление правил в таблице filter - `iptables -F`
##### 2) удаление правил в таблице "NAT" - `iptables -F -t nat`
##### 3) отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`
##### Запускать файл также, как в Части 4
##### Проверить соединение между ws22 и r1 командой `ping`

![](img/7/7.1.r2_firewall.png)

 Запустить файл не получается без привилегий суперпользователя:

![](img/7/7.1.firewall_launch.png)

*При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1*

Действительно не пингуется:

![](img/7/7.1.r1_ping_ws22.png)

##### Добавить в файл ещё одно правило:
##### 4) разрешить маршрутизацию всех пакетов протокола **ICMP**

![](img/7/7.1.r2_firewall_accept.png)

##### Запускать файл также, как в Части 4
##### Проверить соединение между ws22 и r1 командой `ping`

После перезагрузки всех машин начинает пинговаться между r1 и ws22:

![](img/7/7.1.r1_ping_ws22_after.png)

##### Добавить в файл ещё два правила:
##### 5) включить **SNAT**, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)
*Совет: стоит подумать о маршрутизации внутренних пакетов, а также внешних пакетов с установленным соединением*
##### 6) включить **DNAT** на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети
*Совет: стоит учесть, что при попытке подключения возникнет новое tcp-соединение, предназначенное ws22 и 80 порту*

Вот такой в итоге получается файл:

![](img/7/7.6.r2_firewall_final.png)

##### Запускать файл также, как в Части 4
*Перед тестированием рекомендуется отключить сетевой интерфейс **NAT** (его наличие можно проверить командой `ip a`) в VirtualBox, если он включен*
##### Проверить соединение по TCP для **SNAT**, для этого с ws22 подключиться к серверу Apache на r1 командой:
`telnet [адрес] [порт]`
##### Проверить соединение по TCP для **DNAT**, для этого с r1 подключиться к серверу Apache на ws22 командой `telnet` (обращаться по адресу r2 и порту 80)

![](img/7/7.6.telnet_ws22.png)

![](img/7/7.6.telnet_r1_ws22.png)


## Part 8. Дополнительно. Знакомство с **SSH Tunnels**

**== Задание ==**

*В данном задании используются виртуальные машины из Части 5*

##### Запустить на r2 фаервол с правилами из Части 7
##### Запустить веб-сервер **Apache** на ws22 только на localhost (то есть в файле */etc/apache2/ports.conf* изменить строку `Listen 80` на `Listen localhost:80`)

![](img/8/8.1.apache_localhost.png)

![](img/8/8.1.apache_restart.png)

##### Воспользоваться *Local TCP forwarding* с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21

Нам удалось по ssh подключиться с машины ws21 к машине ws22:

![](img/8/8.2.ssh_ws21_ws22.png)

##### Воспользоваться *Remote TCP forwarding* c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11

![](img/8/8.2.ws11_ws22.png)

##### Для проверки, сработало ли подключение в обоих предыдущих пунктах, перейдите во второй терминал (например, клавишами Alt + F2) и выполните команду:
`telnet 127.0.0.1 [локальный порт]`

![](img/8/8.2.ws11_telnet.png)

![](img/8/8.2.ws22_telnet.png)
